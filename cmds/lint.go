package cmds

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/pkg/errors"
	"github.com/spf13/cobra"

	"helm.sh/helm/v3/pkg/action"
)

var longLintHelp = `
This command takes a path to a chart and runs a series of tests to verify that
the chart is well-formed.
If the linter encounters things that will cause the chart to fail installation,
it will emit [ERROR] messages. If it encounters issues that break with convention
or recommendation, it will emit [WARNING] messages.
`

func newLintCmd() *cobra.Command {
	client := action.NewLint()

	cmd := &cobra.Command{
		Use:   "lint PATH",
		Short: "examine a chart for possible issues",
		Long:  longLintHelp,
		RunE: func(cmd *cobra.Command, args []string) error {
			paths := []string{"."}
			if len(args) > 0 {
				paths = args
			}
			if client.WithSubcharts {
				for _, p := range paths {
					filepath.Walk(filepath.Join(p, "charts"), func(path string, info os.FileInfo, err error) error {
						if info != nil {
							if info.Name() == "Chart.yaml" {
								paths = append(paths, filepath.Dir(path))
							} else if strings.HasSuffix(path, ".tgz") || strings.HasSuffix(path, ".tar.gz") {
								paths = append(paths, path)
							}
						}
						return nil
					})
				}
			}

			vals := make(map[string]interface{}, 0)

			var message strings.Builder
			failed := 0

			for _, path := range paths {
				fmt.Fprintf(&message, "==> Linting %s\n", path)

				result := client.Run([]string{path}, vals)

				// All the Errors that are generated by a chart
				// that failed a lint will be included in the
				// results.Messages so we only need to print
				// the Errors if there are no Messages.
				if len(result.Messages) == 0 {
					for _, err := range result.Errors {
						fmt.Fprintf(&message, "Error %s\n", err)
					}
				}

				for _, msg := range result.Messages {
					fmt.Fprintf(&message, "%s\n", msg)
				}

				if len(result.Errors) != 0 {
					failed++
				}

				// Adding extra new line here to break up the
				// results, stops this from being a big wall of
				// text and makes it easier to follow.
				fmt.Fprint(&message, "\n")
			}

			fmt.Fprint(cmd.OutOrStdout(), message.String())

			summary := fmt.Sprintf("%d chart(s) linted, %d chart(s) failed", len(paths), failed)
			if failed > 0 {
				return errors.New(summary)
			}
			fmt.Fprintln(cmd.OutOrStdout(), summary)
			return nil
		},
	}

	f := cmd.Flags()
	f.BoolVar(&client.Strict, "strict", false, "fail on lint warnings")
	f.BoolVar(&client.WithSubcharts, "with-subcharts", false, "lint dependent charts")

	return cmd
}
